<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Blocksmith</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="spinning-block"></div>
        <div class="loading-text">The Blocksmith</div>
        <div class="loading-bar">
            <div class="loading-progress"></div>
        </div>
        <div class="loading-status" id="loadingStatus">Loading...</div>
    </div>

    <!-- Authentication Modal -->
    <div id="authModal" class="modal" style="display: block;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>The Blocksmith</h2>
                <p>Login or create an account to start playing</p>
            </div>
            
            <div class="auth-tabs">
                <button class="tab-btn active" onclick="switchTab('login')">Login</button>
                <button class="tab-btn" onclick="switchTab('register')">Register</button>
            </div>
            
            <div id="authStatus" class="auth-status" style="display: none;"></div>
            
            <!-- Login Form -->
            <form id="loginForm" class="auth-form">
                <div class="form-group">
                    <label for="loginEmail">Email:</label>
                    <input type="email" id="loginEmail" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password:</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <button type="submit" class="btn-primary">Login</button>
            </form>
            
            <!-- Register Form -->
            <form id="registerForm" class="auth-form" style="display: none;">
                <div class="form-group">
                    <label for="registerUsername">Username:</label>
                    <input type="text" id="registerUsername" required>
                </div>
                <div class="form-group">
                    <label for="registerEmail">Email:</label>
                    <input type="email" id="registerEmail" required>
                </div>
                <div class="form-group">
                    <label for="registerPassword">Password:</label>
                    <input type="password" id="registerPassword" required>
                </div>
                <div class="form-group">
                    <label for="registerConfirmPassword">Confirm Password:</label>
                    <input type="password" id="registerConfirmPassword" required>
                </div>
                <button type="submit" class="btn-primary">Create Account</button>
            </form>
            
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content settings-modal">
            <div class="modal-header">
                <h2>Settings</h2>
                <button class="close-btn" onclick="closeSettings()">&times;</button>
            </div>
            
            <div class="settings-container">
                <div class="settings-section">
                    <h3>Theme Settings</h3>
                    <div class="theme-toggle">
                        <label class="toggle-switch">
                            <input type="checkbox" id="darkModeToggle" checked>
                            <span class="slider"></span>
                        </label>
                        <span class="toggle-label">Dark Mode</span>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3>Change Password</h3>
                    <form id="settingsForm">
                        <div class="form-group">
                            <label for="currentPassword">Current Password:</label>
                            <input type="password" id="currentPassword" required>
                        </div>
                        <div class="form-group">
                            <label for="newPassword">New Password:</label>
                            <input type="password" id="newPassword" required>
                        </div>
                        <div class="form-group">
                            <label for="confirmNewPassword">Confirm New Password:</label>
                            <input type="password" id="confirmNewPassword" required>
                        </div>
                        <button type="submit" class="btn-primary">Change Password</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Admin Console Modal -->
    <div id="adminModal" class="modal">
        <div class="modal-content admin-modal">
            <div class="modal-header">
                <h2>Admin Console</h2>
                <button class="close-btn" onclick="closeAdminConsole()">&times;</button>
            </div>
            
            <div class="admin-commands">
                <div class="command-input">
                    <input type="text" id="adminCommandInput" placeholder="Enter command: .give player amount or .remove player amount" autocomplete="off">
                    <button class="btn-execute" onclick="executeAdminCommand()">Execute</button>
                </div>
                <div class="command-examples">
                    <div class="example-command" onclick="fillCommand('.give username 1000')">.give username 1000</div>
                    <div class="example-command" onclick="fillCommand('.remove username 500')">.remove username 500</div>
                </div>
            </div>
            <div class="admin-log" id="adminLog"></div>
        </div>
    </div>

    <!-- Main Game Interface -->
    <div class="game-container">
        <!-- Header -->
        <div class="game-header">
            <div class="game-title">The Blocksmith</div>
            <div class="header-right">
                <div id="userInfo" class="user-info" style="display: none;">
                    <div class="user-details">
                        <span id="usernameDisplay"></span>
                        <span id="userRankBadge" class="rank-badge"></span>
                    </div>
                    <div class="balance-display" id="balanceDisplay" onclick="handleBalanceClick()">$0.00</div>
                    <div class="header-actions">
                        <button class="btn-settings" onclick="showSettings()" title="Settings">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
                            </svg>
                        </button>
                        <button class="btn-logout" onclick="logout()" title="Logout">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M16,17V14H9V10H16V7L21,12L16,17M14,2A2,2 0 0,1 16,4V6H14V4H5V20H14V18H16V20A2,2 0 0,1 14,22H5A2,2 0 0,1 3,20V4A2,2 0 0,1 5,2H14Z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div id="authSection" class="auth-section">
                    <button class="btn-primary" onclick="showAuthModal()">Login</button>
                </div>
            </div>
        </div>

        <!-- Main Game Area -->
        <div class="game-main">
            <!-- Game Panel -->
            <div class="game-panel">
                <div class="game-info">
                    <div class="round-info">
                        <div class="round-number">Round #<span id="roundNumber">1</span></div>
                        <div class="game-mode" id="gameMode">Normal</div>
                    </div>
                    <div class="difficulty-display">
                        <span class="difficulty-label">Difficulty:</span>
                        <div class="difficulty-bar">
                            <div class="difficulty-fill" id="difficultyFill"></div>
                            <span class="difficulty-value" id="difficultyValue">1.0x</span>
                        </div>
                        <div class="difficulty-description" id="difficultyDescription">Medium difficulty</div>
                    </div>
                    <div class="multiplier-display">
                        <span class="multiplier-label">Multiplier:</span>
                        <span class="multiplier-value" id="multiplierValue">1.00x</span>
                    </div>
                </div>

                <!-- Block Progress -->
                <div class="block-container">
                    <div class="block-progress">
                        <div class="block-fill" id="blockFill"></div>
                        <div class="block-percentage" id="blockPercentage">0%</div>
                    </div>
                </div>

                <!-- Betting Area -->
                <div class="betting-area">
                    <div class="bet-input">
                        <label for="betAmount">Bet Amount:</label>
                        <input type="number" id="betAmount" min="0.01" step="0.01" placeholder="Enter bet amount">
                    </div>
                    
                    <div class="quick-bet-amounts">
                        <button class="quick-bet-btn" onclick="setBetAmount(1)">$1</button>
                        <button class="quick-bet-btn" onclick="setBetAmount(5)">$5</button>
                        <button class="quick-bet-btn" onclick="setBetAmount(10)">$10</button>
                        <button class="quick-bet-btn" onclick="setBetAmount(25)">$25</button>
                        <button class="quick-bet-btn" onclick="setBetAmount(50)">$50</button>
                        <button class="quick-bet-btn" onclick="setBetAmount(100)">$100</button>
                    </div>
                    
                    <div class="fraction-bet-options">
                        <button class="fraction-bet-btn" onclick="setBetFraction(0.25)">1/4 IN</button>
                        <button class="fraction-bet-btn" onclick="setBetFraction(0.5)">1/2 IN</button>
                        <button class="fraction-bet-btn" onclick="setBetFraction(1)">ALL IN</button>
                    </div>
                    
                    <div class="bet-actions">
                        <button id="betButton" class="btn-bet" onclick="placeBet()">START MINING</button>
                        <button id="cashoutButton" class="btn-cashout" onclick="cashOut()" disabled>CASH OUT</button>
                    </div>
                </div>
            </div>

            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Leaderboard -->
                <div class="leaderboard">
                    <h3>Leaderboard</h3>
                    <div class="leaderboard-list" id="leaderboardList">
                        <!-- Leaderboard items will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Game History -->
                <div class="game-history">
                    <h3>Your Game History</h3>
                    <div class="history-list" id="historyList">
                        <!-- Game history will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/12.2.1/firebase-auth-compat.js"></script>

    <script src="crypto-js.min.js"></script>
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyC6z9d-NbWe3kEnXnP48qmfH2-kwW4Vz7E",
            authDomain: "block-abd5a.firebaseapp.com",
            databaseURL: "https://block-abd5a-default-rtdb.firebaseio.com",
            projectId: "block-abd5a",
            storageBucket: "block-abd5a.firebasestorage.app",
            messagingSenderId: "883132297964",
            appId: "1:883132297964:web:44634d8250fa29872a6bc9",
            measurementId: "G-E2XZX95N0T"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const auth = firebase.auth();

        // Simple Firebase Game Class
        class SimpleFirebaseGame {
            constructor() {
                this.currentUser = null;
                this.gameState = 'waiting';
                this.currentBet = 0;
                this.currentMultiplier = 1.0;
                this.blockProgress = 0;
                this.currentRound = 1;
                this.currentMode = 'Normal';
                this.currentDifficulty = 1.0;
                
                this.config = {
                    normalModeChance: 0.9,
                    hotModeChance: 0.1,
                    normalMaxMultiplier: 2.5,
                    hotMaxMultiplier: 10.0,
                    orphanBaseChance: 0.001,
                    orphanMaxChance: 0.95,
                    difficultyRange: [0.5, 3.0]
                };
                
                this.init();
            }
            
            async init() {
                console.log('Initializing Simple Firebase Game...');
                this.showLoading('Initializing...');
                
                try {
                    this.setupEventListeners();
                    await this.checkAuthState();
                    
                    // Test database connection first
                    console.log('Testing database connection...');
                    try {
                        // Try to write a test value first
                        await database.ref('test').set({ timestamp: new Date().toISOString() });
                        console.log('Database write test successful');
                        
                        // Then try to read it
                        const testSnapshot = await database.ref('test').once('value');
                        console.log('Database read test successful:', testSnapshot.val());
                        
                        // Clean up test data
                        await database.ref('test').remove();
                        console.log('Database connection test successful');
                    } catch (dbError) {
                        console.error('Database connection test failed:', dbError);
                        console.error('Error code:', dbError.code);
                        console.error('Error message:', dbError.message);
                        throw new Error('Database connection failed: ' + dbError.message);
                    }
                    
                    // Only update leaderboard if user is authenticated
                    if (this.currentUser) {
                        await this.updateLeaderboard();
                    } else {
                        console.log('No user authenticated, skipping leaderboard update');
                    }
                    
                    console.log('Firebase game initialization complete');
                } catch (error) {
                    console.error('Error initializing Firebase game:', error);
                    this.showStatus('Error initializing game. Please refresh.', 'error');
                } finally {
                    this.hideLoading();
                }
            }
            
            setupEventListeners() {
                // Auth forms
                const loginForm = document.getElementById('loginForm');
                const registerForm = document.getElementById('registerForm');
                
                if (loginForm) {
                    loginForm.addEventListener('submit', (e) => this.handleLogin(e));
                }
                
                if (registerForm) {
                    registerForm.addEventListener('submit', (e) => this.handleRegister(e));
                }
                
                // Settings form
                const settingsForm = document.getElementById('settingsForm');
                if (settingsForm) {
                    settingsForm.addEventListener('submit', (e) => this.handlePasswordChange(e));
                }
                
                // Dark mode toggle
                const darkModeToggle = document.getElementById('darkModeToggle');
                if (darkModeToggle) {
                    darkModeToggle.addEventListener('change', (e) => this.toggleDarkMode(e));
                }
                
                
                // Game controls
                const betButton = document.getElementById('betButton');
                const cashoutButton = document.getElementById('cashoutButton');
                
                if (betButton) {
                    betButton.addEventListener('click', () => this.placeBet());
                }
                
                if (cashoutButton) {
                    cashoutButton.addEventListener('click', () => this.cashOut());
                }
                
                // Click outside modal to close functionality
                this.setupModalClickOutside();
                
                // Balance click for admin
                const balanceDisplay = document.getElementById('balanceDisplay');
                if (balanceDisplay) {
                    balanceDisplay.addEventListener('click', () => this.handleBalanceClick());
                }
            }
            
            async checkAuthState() {
                return new Promise((resolve) => {
                    auth.onAuthStateChanged(async (user) => {
                        if (user) {
                            console.log('User signed in:', user.email);
                            
                            // Clear any existing game state
                            if (this.miningInterval) {
                                clearInterval(this.miningInterval);
                                this.miningInterval = null;
                            }
                            
                            this.gameState = 'waiting';
                            this.currentBet = 0;
                            this.currentMultiplier = 1.0;
                            this.blockProgress = 0;
                            
                            // Reset UI elements
                            document.getElementById('betButton').disabled = false;
                            document.getElementById('cashoutButton').disabled = true;
                            document.getElementById('betAmount').disabled = false;
                            document.getElementById('blockFill').style.width = '0%';
                            document.getElementById('blockPercentage').textContent = '0%';
                            document.getElementById('multiplierValue').textContent = '1.00x';
                            
                            const userData = await this.getUserData(user.uid);
                            this.currentUser = { ...user, ...userData };
                            this.updateUI();
                            this.hideAuthModal();
                        } else {
                            console.log('No user signed in');
                            this.showAuthModal();
                        }
                        resolve();
                    });
                });
            }
            
            async handleLogin(e) {
                e.preventDefault();
                
                const email = document.getElementById('loginEmail').value;
                const password = document.getElementById('loginPassword').value;
                
                if (!email || !password) {
                    this.showStatus('Please fill in all fields', 'error');
                    return;
                }
                
                this.showLoading('Logging in...');
                
                try {
                    const userCredential = await auth.signInWithEmailAndPassword(email, password);
                    const user = userCredential.user;
                    
                    const userData = await this.getUserData(user.uid);
                    this.currentUser = { ...user, ...userData };
                    
                    this.hideAuthModal();
                    this.updateUI();
                    this.showStatus('Login successful!', 'success');
                } catch (error) {
                    this.showStatus('Login failed: ' + error.message, 'error');
                } finally {
                    this.hideLoading();
                }
            }
            
            async handleRegister(e) {
                e.preventDefault();
                
                const username = document.getElementById('registerUsername').value;
                const email = document.getElementById('registerEmail').value;
                const password = document.getElementById('registerPassword').value;
                const confirmPassword = document.getElementById('registerConfirmPassword').value;
                
                if (!username || !email || !password || !confirmPassword) {
                    this.showStatus('Please fill in all fields', 'error');
                    return;
                }
                
                if (password !== confirmPassword) {
                    this.showStatus('Passwords do not match', 'error');
                    return;
                }
                
                if (password.length < 6) {
                    this.showStatus('Password must be at least 6 characters', 'error');
                    return;
                }
                
                this.showLoading('Creating account...');
                
                try {
                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    const user = userCredential.user;
                    
                    // Create user profile with special ranks
                    let userRank = 'user';
                    if (username.toLowerCase() === 'iydl') {
                        userRank = 'owner';
                    } else if (username.toLowerCase() === 'x3') {
                        userRank = 'admin';
                    }
                    
                    const userData = {
                        uid: user.uid,
                        username: username,
                        email: email,
                        balance: 100,
                        rank: userRank,
                        createdAt: new Date().toISOString(),
                        totalWagered: 0,
                        totalWon: 0,
                        gamesPlayed: 0
                    };
                    
                    await database.ref(`users/${user.uid}`).set(userData);
                    await database.ref(`usernames/${username}`).set(user.uid);
                    
                    this.currentUser = { ...user, ...userData };
                    this.hideAuthModal();
                    this.updateUI();
                    this.showStatus('Account created successfully!', 'success');
                } catch (error) {
                    this.showStatus('Registration failed: ' + error.message, 'error');
                } finally {
                    this.hideLoading();
                }
            }
            
            async getUserData(uid) {
                try {
                    const snapshot = await database.ref(`users/${uid}`).once('value');
                    return snapshot.val();
                } catch (error) {
                    console.error('Error getting user data:', error);
                    return null;
                }
            }
            
            async updateLeaderboard() {
                try {
                    console.log('Updating leaderboard...');
                    console.log('Database object:', database);
                    console.log('Database ref:', database.ref);
                    
                    // Check if user is authenticated
                    const currentUser = auth.currentUser;
                    console.log('Current authenticated user:', currentUser);
                    
                    if (!currentUser) {
                        console.log('No authenticated user, cannot access leaderboard');
                        const leaderboardList = document.getElementById('leaderboardList');
                        if (leaderboardList) {
                            leaderboardList.innerHTML = '<div class="no-data">Please login to view leaderboard</div>';
                        }
                        return;
                    }
                    
                    console.log('User is authenticated, attempting to read users...');
                    const snapshot = await database.ref('users').once('value');
                    const users = snapshot.val();
                    
                    console.log('Raw snapshot:', snapshot);
                    console.log('Users from Firebase:', users);
                    console.log('Users type:', typeof users);
                    console.log('Users keys:', users ? Object.keys(users) : 'null');
                    
                    const leaderboardList = document.getElementById('leaderboardList');
                    if (!leaderboardList) {
                        console.error('Leaderboard list element not found');
                        return;
                    }
                    
                    leaderboardList.innerHTML = '';
                    
                    if (!users || typeof users !== 'object') {
                        console.log('No users found in Firebase or invalid data type');
                        leaderboardList.innerHTML = '<div class="no-data">No players yet</div>';
                        return;
                    }
                    
                    // Get all users with valid data and sort by balance
                    const userArray = Object.values(users);
                    console.log('User array:', userArray);
                    
                    const validUsers = userArray.filter(user => {
                        const isValid = user && 
                                       user.username && 
                                       typeof user.balance === 'number' && 
                                       !isNaN(user.balance);
                        if (!isValid) {
                            console.log('Invalid user filtered out:', user);
                        }
                        return isValid;
                    });
                    
                    console.log('Valid users:', validUsers);
                    
                    const sortedUsers = validUsers.sort((a, b) => b.balance - a.balance);
                    console.log('Sorted users:', sortedUsers);
                    
                    // Take top 10
                    const top10 = sortedUsers.slice(0, 10);
                    console.log('Top 10 users:', top10);
                    
                    if (top10.length === 0) {
                        // Show a message encouraging users to play
                        leaderboardList.innerHTML = `
                            <div class="no-data">
                                <div style="text-align: center; padding: 20px;">
                                    <div style="font-size: 1.2rem; margin-bottom: 10px;">üèÜ</div>
                                    <div>No players yet</div>
                                    <div style="font-size: 0.9rem; color: #888; margin-top: 5px;">
                                        Be the first to play and appear on the leaderboard!
                                    </div>
                                </div>
                            </div>
                        `;
                        return;
                    }
                    
                    // Create leaderboard items
                    top10.forEach((user, index) => {
                        const item = document.createElement('div');
                        item.className = 'leaderboard-item';
                        
                        // Rank badge
                        let rankBadge = '';
                        if (user.rank === 'owner') {
                            rankBadge = '<span class="rank-badge owner">OWNER</span>';
                        } else if (user.rank === 'admin') {
                            rankBadge = '<span class="rank-badge admin">ADMIN</span>';
                        } else if (user.rank === 'elite') {
                            rankBadge = '<span class="rank-badge elite">ELITE</span>';
                        }
                        
                        // Position styling
                        let positionClass = '';
                        if (index === 0) positionClass = 'first';
                        else if (index === 1) positionClass = 'second';
                        else if (index === 2) positionClass = 'third';
                        
                        item.innerHTML = `
                            <div class="leaderboard-rank ${positionClass}">#${index + 1}</div>
                            <div class="leaderboard-info">
                                <div class="leaderboard-username">
                                    ${user.username}
                                    ${rankBadge}
                                </div>
                                <div class="leaderboard-balance">$${this.formatNumber(user.balance)}</div>
                            </div>
                        `;
                        leaderboardList.appendChild(item);
                    });
                    
                    console.log('Leaderboard updated successfully with', top10.length, 'players');
                } catch (error) {
                    console.error('Error updating leaderboard:', error);
                    console.error('Error details:', error.message);
                    console.error('Error stack:', error.stack);
                    
                    const leaderboardList = document.getElementById('leaderboardList');
                    if (leaderboardList) {
                        leaderboardList.innerHTML = `<div class="no-data">Error: ${error.message}</div>`;
                    }
                }
            }
            
            async loadGameHistory() {
                if (!this.currentUser) return;
                
                try {
                    console.log('Loading game history...');
                    const snapshot = await database.ref(`games/${this.currentUser.uid}`).orderByChild('timestamp').limitToLast(100).once('value');
                    const games = snapshot.val();
                    
                    console.log('Games from Firebase:', games);
                    
                    const historyList = document.getElementById('historyList');
                    if (!historyList) {
                        console.error('History list element not found');
                        return;
                    }
                    
                    historyList.innerHTML = '';
                    
                    if (!games) {
                        historyList.innerHTML = '<div class="no-data">No games played yet</div>';
                        return;
                    }
                    
                    const gameArray = Object.values(games).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    
                    console.log('Game history data:', gameArray);
                    
                    gameArray.forEach((game) => {
                        const item = document.createElement('div');
                        item.className = 'history-item';
                        
                        const resultClass = game.won ? 'win' : 'loss';
                        const resultText = game.won ? `+$${this.formatNumber(game.winnings)}` : `-$${this.formatNumber(game.bet)}`;
                        
                        const date = new Date(game.timestamp).toLocaleDateString();
                        const time = new Date(game.timestamp).toLocaleTimeString();
                        
                        item.innerHTML = `
                            <div class="history-info">
                                <div class="history-round">${game.mode} - ${game.difficulty.toFixed(1)}x</div>
                                <div class="history-multiplier">${game.multiplier.toFixed(2)}x</div>
                                <div class="history-date">${date} ${time}</div>
                            </div>
                            <div class="history-result ${resultClass}">${resultText}</div>
                        `;
                        historyList.appendChild(item);
                    });
                } catch (error) {
                    console.error('Error loading game history:', error);
                }
            }
            
            async placeBet() {
                if (!this.currentUser) {
                    this.showStatus('Please log in to play', 'error');
                    return;
                }
                
                const betAmount = parseFloat(document.getElementById('betAmount').value);
                
                if (isNaN(betAmount) || betAmount <= 0) {
                    this.showStatus('Please enter a valid bet amount', 'error');
                    return;
                }
                
                if (betAmount > this.currentUser.balance) {
                    this.showStatus('Insufficient balance', 'error');
                    return;
                }
                
                // Clear any existing mining state
                this.clearMiningState();
                
                this.currentBet = betAmount;
                this.gameState = 'mining';
                this.blockProgress = 0;
                this.currentMultiplier = 1.0;
                
                this.generateGameOutcome();
                this.updateDifficultyDisplay();
                
                document.getElementById('betButton').disabled = true;
                document.getElementById('cashoutButton').disabled = false;
                document.getElementById('betAmount').disabled = true;
                
                // Reset UI elements
                document.getElementById('blockFill').style.width = '0%';
                document.getElementById('blockPercentage').textContent = '0%';
                document.getElementById('multiplierValue').textContent = '1.00x';
                
                this.updateUI();
                this.startMining();
            }
            
            async cashOut() {
                if (this.gameState !== 'mining') return;
                
                const winnings = this.currentBet * this.currentMultiplier;
                const profit = winnings - this.currentBet;
                
                const newBalance = this.currentUser.balance + profit;
                await database.ref(`users/${this.currentUser.uid}/balance`).set(newBalance);
                this.currentUser.balance = newBalance;
                
                await this.saveGameResult(true, winnings);
                
                this.endGame(true, winnings);
                this.showStatus(`Cashed out at ${this.currentMultiplier.toFixed(2)}x! Won $${this.formatNumber(winnings)}`, 'success');
            }
            
            async endGame(won, winnings = 0) {
                // Clear mining state to prevent freezing
                this.clearMiningState();
                
                this.gameState = 'completed';
                
                if (!won) {
                    const newBalance = this.currentUser.balance - this.currentBet;
                    await database.ref(`users/${this.currentUser.uid}/balance`).set(newBalance);
                    this.currentUser.balance = newBalance;
                    
                    await this.saveGameResult(false, 0);
                }
                
                // Reset game state
                this.gameState = 'waiting';
                this.currentBet = 0;
                this.currentMultiplier = 1.0;
                this.blockProgress = 0;
                
                // Reset UI elements
                document.getElementById('betButton').disabled = false;
                document.getElementById('cashoutButton').disabled = true;
                document.getElementById('betAmount').disabled = false;
                document.getElementById('blockFill').style.width = '0%';
                document.getElementById('blockPercentage').textContent = '0%';
                document.getElementById('multiplierValue').textContent = '1.00x';
                
                this.updateUI();
                this.updateLeaderboard();
                
                // Auto-recovery: if balance drops below $1, restore to $100
                if (this.currentUser && this.currentUser.balance < 1) {
                    console.log('Balance below $1, auto-recovering to $100');
                    this.currentUser.balance = 100;
                    await database.ref(`users/${this.currentUser.uid}/balance`).set(100);
                    this.updateUI();
                    this.updateLeaderboard();
                    this.showStatus('Balance recovered to $100!', 'success');
                }
                
                // Increment round after delay
                setTimeout(() => {
                    this.currentRound++;
                    document.getElementById('roundNumber').textContent = this.currentRound;
                    this.gameState = 'waiting';
                }, 2000);
            }
            
            async saveGameResult(won, winnings) {
                try {
                    const gameData = {
                        bet: this.currentBet,
                        multiplier: this.currentMultiplier,
                        winnings: winnings,
                        won: won,
                        mode: this.currentMode,
                        difficulty: this.currentDifficulty,
                        timestamp: new Date().toISOString()
                    };
                    
                    await database.ref(`games/${this.currentUser.uid}`).push(gameData);
                } catch (error) {
                    console.error('Error saving game result:', error);
                }
            }
            
            generateGameOutcome() {
                const modeRandom = Math.random();
                this.currentMode = modeRandom < this.config.normalModeChance ? 'Normal' : 'Hot';
                
                const difficultyRandom = Math.random();
                this.currentDifficulty = this.config.difficultyRange[0] + 
                    (difficultyRandom * (this.config.difficultyRange[1] - this.config.difficultyRange[0]));
                
                document.getElementById('gameMode').textContent = this.currentMode;
                this.updateDifficultyDisplay();
            }
            
            startMining() {
                // Clear any existing mining state
                this.clearMiningState();
                
                // Safety timeout to prevent infinite mining
                this.miningTimeout = setTimeout(() => {
                    console.log('Mining timeout reached, forcing game end');
                    this.forceEndGame();
                }, 30000); // 30 second timeout
                
                this.miningInterval = setInterval(() => {
                    try {
                        if (this.gameState !== 'mining') {
                            this.clearMiningState();
                            return;
                        }
                        
                        this.updateMining();
                    } catch (error) {
                        console.error('Error in mining update:', error);
                        this.forceEndGame();
                    }
                }, 50);
            }
            
            clearMiningState() {
                if (this.miningInterval) {
                    clearInterval(this.miningInterval);
                    this.miningInterval = null;
                }
                if (this.miningTimeout) {
                    clearTimeout(this.miningTimeout);
                    this.miningTimeout = null;
                }
            }
            
            forceEndGame() {
                console.log('Force ending game due to error or timeout');
                this.clearMiningState();
                
                // Reset game state
                this.gameState = 'waiting';
                this.currentBet = 0;
                this.currentMultiplier = 1.0;
                this.blockProgress = 0;
                
                // Reset UI
                document.getElementById('betButton').disabled = false;
                document.getElementById('cashoutButton').disabled = true;
                document.getElementById('betAmount').disabled = false;
                document.getElementById('blockFill').style.width = '0%';
                document.getElementById('blockPercentage').textContent = '0%';
                document.getElementById('multiplierValue').textContent = '1.00x';
                
                this.updateUI();
                this.showStatus('Game reset due to error. Please try again.', 'error');
            }
            
            updateMining() {
                const increment = this.currentMode === 'Hot' ? 0.5 : 0.2;
                this.blockProgress += increment;
                
                if (this.currentMode === 'Normal') {
                    this.currentMultiplier = 1.0 + (this.blockProgress / 100) * (this.config.normalMaxMultiplier - 1.0);
                } else {
                    this.currentMultiplier = 1.0 + (this.blockProgress / 100) * (this.config.hotMaxMultiplier - 1.0);
                }
                
                document.getElementById('blockFill').style.width = this.blockProgress + '%';
                document.getElementById('blockPercentage').textContent = Math.round(this.blockProgress) + '%';
                document.getElementById('multiplierValue').textContent = this.currentMultiplier.toFixed(2) + 'x';
                
                if (this.shouldOrphan()) {
                    this.handleOrphan();
                    return;
                }
                
                if (this.blockProgress >= 100) {
                    this.handleBlockComplete();
                }
            }
            
            shouldOrphan() {
                const progress = this.blockProgress / 100;
                const maxProgress = Math.max(0.1, 1.0 - (this.currentDifficulty - 0.5) * 0.3);
                
                if (progress >= maxProgress) {
                    return true;
                }
                
                const normalizedProgress = progress / maxProgress;
                const baseOrphanChance = this.config.orphanBaseChance + 
                    (this.config.orphanMaxChance - this.config.orphanBaseChance) * Math.pow(normalizedProgress, 3);
                
                return Math.random() < baseOrphanChance;
            }
            
            handleOrphan() {
                this.endGame(false);
                this.showStatus('Block orphaned! You lost your bet.', 'error');
            }
            
            handleBlockComplete() {
                const winnings = this.currentBet * this.currentMultiplier;
                this.currentUser.balance += winnings - this.currentBet;
                this.endGame(true, winnings);
                this.showStatus(`Block completed! Won $${this.formatNumber(winnings)}`, 'success');
            }
            
            updateDifficultyDisplay() {
                const difficultyValue = document.getElementById('difficultyValue');
                const difficultyFill = document.getElementById('difficultyFill');
                const difficultyDescription = document.getElementById('difficultyDescription');
                
                if (difficultyValue) {
                    difficultyValue.textContent = this.currentDifficulty.toFixed(1) + 'x';
                }
                
                if (difficultyFill) {
                    const minDiff = this.config.difficultyRange[0];
                    const maxDiff = this.config.difficultyRange[1];
                    const percentage = ((this.currentDifficulty - minDiff) / (maxDiff - minDiff)) * 100;
                    difficultyFill.style.width = percentage + '%';
                    
                    if (this.currentDifficulty <= 0.8) {
                        difficultyFill.style.background = 'linear-gradient(90deg, #00ff88 0%, #00d4aa 100%)';
                    } else if (this.currentDifficulty <= 1.5) {
                        difficultyFill.style.background = 'linear-gradient(90deg, #feca57 0%, #ff9ff3 100%)';
                    } else {
                        difficultyFill.style.background = 'linear-gradient(90deg, #ff6b6b 0%, #ee5a24 100%)';
                    }
                }
                
                if (difficultyDescription) {
                    const maxProgress = Math.max(0.1, 1.0 - (this.currentDifficulty - 0.5) * 0.3);
                    const maxProgressPercent = Math.round(maxProgress * 100);
                    
                    if (this.currentDifficulty <= 0.7) {
                        difficultyDescription.textContent = `Can reach ~${maxProgressPercent}%`;
                    } else if (this.currentDifficulty <= 1.2) {
                        difficultyDescription.textContent = `Max ~${maxProgressPercent}%`;
                    } else if (this.currentDifficulty <= 2.0) {
                        difficultyDescription.textContent = `Breaks at ~${maxProgressPercent}%`;
                    } else {
                        difficultyDescription.textContent = `Very risky - ~${maxProgressPercent}%`;
                    }
                }
            }
            
            handleBalanceClick() {
                if (!this.currentUser) return;
                
                this.balanceClickCount = (this.balanceClickCount || 0) + 1;
                
                if (this.balanceClickCount >= 5) {
                    this.showAdminConsole();
                    this.balanceClickCount = 0;
                }
                
                setTimeout(() => {
                    this.balanceClickCount = 0;
                }, 3000);
            }
            
            showAdminConsole() {
                const adminModal = document.getElementById('adminModal');
                if (adminModal) {
                    adminModal.style.display = 'block';
                }
            }
            
            async executeAdminCommand() {
                if (!this.currentUser || this.currentUser.rank !== 'owner') {
                    this.logAdminCommand('Access denied: Owner privileges required');
                    return;
                }
                
                const commandInput = document.getElementById('adminCommandInput');
                const command = commandInput.value.trim();
                
                if (!command) {
                    this.logAdminCommand('Please enter a command');
                    return;
                }
                
                this.logAdminCommand(`> ${command}`);
                
                const parts = command.split(/\s+/).filter(part => part.length > 0);
                const cmd = parts[0].toLowerCase();
                
                if (cmd === '.give' && parts.length >= 3) {
                    const player = parts[1];
                    const amountStr = parts.slice(2).join(' ');
                    const cleanAmountStr = amountStr.replace(/[$,\s]/g, '');
                    const amount = parseFloat(cleanAmountStr);
                    
                    if (isNaN(amount) || amount <= 0) {
                        this.logAdminCommand(`Invalid amount: "${amountStr}". Amount must be a positive number.`);
                        return;
                    }
                    
                    try {
                        const snapshot = await database.ref('users').once('value');
                        const users = snapshot.val();
                        const targetUser = Object.values(users).find(user => user.username === player);
                        
                        if (!targetUser) {
                            this.logAdminCommand(`User "${player}" not found`);
                            return;
                        }
                        
                        const newBalance = targetUser.balance + amount;
                        await database.ref(`users/${targetUser.uid}/balance`).set(newBalance);
                        
                        this.logAdminCommand(`‚úì Gave $${this.formatNumber(amount)} to ${player}. New balance: $${this.formatNumber(newBalance)}`);
                        this.updateLeaderboard();
                    } catch (error) {
                        this.logAdminCommand(`Error: ${error.message}`);
                    }
                } else if (cmd === '.remove' && parts.length >= 3) {
                    const player = parts[1];
                    const amountStr = parts.slice(2).join(' ');
                    const cleanAmountStr = amountStr.replace(/[$,\s]/g, '');
                    const amount = parseFloat(cleanAmountStr);
                    
                    if (isNaN(amount) || amount <= 0) {
                        this.logAdminCommand(`Invalid amount: "${amountStr}". Amount must be a positive number.`);
                        return;
                    }
                    
                    try {
                        const snapshot = await database.ref('users').once('value');
                        const users = snapshot.val();
                        const targetUser = Object.values(users).find(user => user.username === player);
                        
                        if (!targetUser) {
                            this.logAdminCommand(`User "${player}" not found`);
                            return;
                        }
                        
                        const newBalance = Math.max(0, targetUser.balance - amount);
                        await database.ref(`users/${targetUser.uid}/balance`).set(newBalance);
                        
                        this.logAdminCommand(`‚úì Removed $${this.formatNumber(amount)} from ${player}. New balance: $${this.formatNumber(newBalance)}`);
                        this.updateLeaderboard();
                    } catch (error) {
                        this.logAdminCommand(`Error: ${error.message}`);
                    }
                } else {
                    this.logAdminCommand(`Invalid command. Available commands:`);
                    this.logAdminCommand(`.give player amount - Give money to player`);
                    this.logAdminCommand(`.remove player amount - Remove money from player`);
                }
                
                commandInput.value = '';
            }
            
            logAdminCommand(message) {
                const log = document.getElementById('adminLog');
                const timestamp = new Date().toLocaleTimeString();
                log.innerHTML += `[${timestamp}] ${message}\n`;
                log.scrollTop = log.scrollHeight;
            }
            
            formatNumber(num) {
                return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }
            
            showLoading(status) {
                const loadingScreen = document.getElementById('loadingScreen');
                const loadingStatus = document.getElementById('loadingStatus');
                if (loadingScreen) {
                    loadingScreen.style.display = 'flex';
                    if (loadingStatus) {
                        loadingStatus.textContent = status;
                    }
                }
            }
            
            hideLoading() {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }
            }
            
            showStatus(message, type) {
                const statusDiv = document.getElementById('authStatus');
                if (statusDiv) {
                    statusDiv.textContent = message;
                    statusDiv.className = `auth-status ${type}`;
                    statusDiv.style.display = 'block';
                    
                    setTimeout(() => {
                        statusDiv.style.display = 'none';
                    }, 5000);
                }
            }
            
            showAuthModal() {
                const authModal = document.getElementById('authModal');
                if (authModal) {
                    authModal.style.display = 'block';
                }
            }
            
            hideAuthModal() {
                const authModal = document.getElementById('authModal');
                if (authModal) {
                    authModal.style.display = 'none';
                }
            }
            
            updateUI() {
                if (this.currentUser) {
                    document.getElementById('balanceDisplay').textContent = '$' + this.formatNumber(this.currentUser.balance);
                    document.getElementById('usernameDisplay').textContent = this.currentUser.username;
                    document.getElementById('userInfo').style.display = 'flex';
                    document.getElementById('authSection').style.display = 'none';
                    
                    const rankBadge = document.getElementById('userRankBadge');
                    if (rankBadge) {
                        if (this.currentUser.rank === 'owner') {
                            rankBadge.textContent = 'OWNER';
                            rankBadge.className = 'rank-badge owner';
                        } else if (this.currentUser.rank === 'admin') {
                            rankBadge.textContent = 'ADMIN';
                            rankBadge.className = 'rank-badge admin';
                        } else if (this.currentUser.rank === 'elite') {
                            rankBadge.textContent = 'ELITE';
                            rankBadge.className = 'rank-badge elite';
                        } else {
                            rankBadge.textContent = '';
                            rankBadge.className = '';
                        }
                    }
                    
                    // Load game history when user logs in
                    this.loadGameHistory();
                } else {
                    document.getElementById('userInfo').style.display = 'none';
                    document.getElementById('authSection').style.display = 'flex';
                }
            }
            
            
            setupModalClickOutside() {
                // Auth modal click outside to close
                const authModal = document.getElementById('authModal');
                if (authModal) {
                    authModal.addEventListener('click', (e) => {
                        if (e.target === authModal) {
                            this.closeModal();
                        }
                    });
                }
                
                // Settings modal click outside to close
                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal) {
                    settingsModal.addEventListener('click', (e) => {
                        if (e.target === settingsModal) {
                            this.closeSettings();
                        }
                    });
                }
                
                // Admin modal click outside to close
                const adminModal = document.getElementById('adminModal');
                if (adminModal) {
                    adminModal.addEventListener('click', (e) => {
                        if (e.target === adminModal) {
                            this.closeAdminConsole();
                        }
                    });
                }
            }
            
            closeModal() {
                document.getElementById('authModal').style.display = 'none';
            }
            
            closeAdminConsole() {
                document.getElementById('adminModal').style.display = 'none';
            }
            
            async handlePasswordChange(e) {
                e.preventDefault();
                
                if (!this.currentUser) {
                    this.showStatus('Please log in first', 'error');
                    return;
                }
                
                const currentPassword = document.getElementById('currentPassword').value;
                const newPassword = document.getElementById('newPassword').value;
                const confirmPassword = document.getElementById('confirmNewPassword').value;
                
                if (!currentPassword || !newPassword || !confirmPassword) {
                    this.showStatus('Please fill in all fields', 'error');
                    return;
                }
                
                if (newPassword !== confirmPassword) {
                    this.showStatus('New passwords do not match', 'error');
                    return;
                }
                
                if (newPassword.length < 6) {
                    this.showStatus('New password must be at least 6 characters', 'error');
                    return;
                }
                
                this.showLoading('Changing password...');
                
                try {
                    // Re-authenticate user with current password
                    const credential = firebase.auth.EmailAuthProvider.credential(this.currentUser.email, currentPassword);
                    await this.currentUser.reauthenticateWithCredential(credential);
                    
                    // Update password
                    await this.currentUser.updatePassword(newPassword);
                    
                    this.showStatus('Password changed successfully!', 'success');
                    
                    // Clear form
                    document.getElementById('currentPassword').value = '';
                    document.getElementById('newPassword').value = '';
                    document.getElementById('confirmNewPassword').value = '';
                } catch (error) {
                    this.showStatus('Password change failed: ' + error.message, 'error');
                } finally {
                    this.hideLoading();
                }
            }
            
            toggleDarkMode(e) {
                const isDark = e.target.checked;
                document.body.classList.toggle('light-mode', !isDark);
                localStorage.setItem('darkMode', isDark);
            }
            
            loadTheme() {
                const savedTheme = localStorage.getItem('darkMode');
                const isDark = savedTheme !== null ? savedTheme === 'true' : true;
                
                document.body.classList.toggle('light-mode', !isDark);
                const darkModeToggle = document.getElementById('darkModeToggle');
                if (darkModeToggle) {
                    darkModeToggle.checked = isDark;
                }
            }
        }

        // Global functions
        function switchTab(tab) {
            document.querySelectorAll('.auth-form').forEach(form => form.style.display = 'none');
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            
            if (tab === 'login') {
                document.getElementById('loginForm').style.display = 'block';
                document.querySelector('.tab-btn[onclick="switchTab(\'login\')"]').classList.add('active');
            } else if (tab === 'register') {
                document.getElementById('registerForm').style.display = 'block';
                document.querySelector('.tab-btn[onclick="switchTab(\'register\')"]').classList.add('active');
            }
        }

        function showAuthModal() {
            document.getElementById('authModal').style.display = 'block';
        }

        function showSettings() {
            document.getElementById('settingsModal').style.display = 'block';
        }

        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        function closeModal() {
            document.getElementById('authModal').style.display = 'none';
        }


        function closeAdminConsole() {
            document.getElementById('adminModal').style.display = 'none';
        }

        function handleBalanceClick() {
            if (game) {
                game.handleBalanceClick();
            }
        }

        function executeAdminCommand() {
            if (game) {
                game.executeAdminCommand();
            }
        }

        function fillCommand(command) {
            const commandInput = document.getElementById('adminCommandInput');
            if (commandInput) {
                commandInput.value = command;
                commandInput.focus();
            }
        }

        function setBetAmount(amount) {
            if (game && game.currentUser) {
                const maxBet = game.currentUser.balance;
                const betAmount = Math.min(amount, maxBet);
                document.getElementById('betAmount').value = betAmount;
                
                document.querySelectorAll('.quick-bet-btn').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
            }
        }

        function setBetFraction(fraction) {
            if (game && game.currentUser) {
                let betAmount;
                
                if (fraction === 1) {
                    betAmount = Math.max(0, game.currentUser.balance - 0.01);
                } else {
                    betAmount = game.currentUser.balance * fraction;
                }
                
                document.getElementById('betAmount').value = betAmount.toFixed(2);
                
                document.querySelectorAll('.fraction-bet-btn').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
            }
        }

        function placeBet() {
            if (game) {
                game.placeBet();
            }
        }

        function cashOut() {
            if (game) {
                game.cashOut();
            }
        }

        function logout() {
            if (game) {
                auth.signOut().then(() => {
                    game.currentUser = null;
                    game.showAuthModal();
                    game.showStatus('Logged out successfully', 'success');
                });
            }
        }

        // Initialize Game
        let game;
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing Firebase game...');
            try {
                game = new SimpleFirebaseGame();
                console.log('Firebase game initialized successfully');
            } catch (error) {
                console.error('Error initializing Firebase game:', error);
            }
        });
    </script>
</body>
</html>
